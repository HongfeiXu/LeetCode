# Greedy Algorithm

## 什么是贪心算法
>Ref: CLRS Chapter 16
>Ref: https://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/

贪心算法就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。这种启发式策略并不保证总能找到最优解，但对有些问题确实有效。

一般，我们可以按如下步骤设计贪心算法：
1. 将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。
2. 证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。
3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。

如何证明一个贪心算法能够解一个最优化问题呢？并没有适合所有情况的方法，但**贪心选择性质**和**最优子结构**是两个关键要素。

- 贪心选择性质

**我们可以通过做出局部最优选择来构造全局最优解**。这也是贪心算法与动态规划的不同之处。在动态规划方法中，每个步骤都要进行一次选择，但选择通常依赖于子问题的解。因此，我们通常以一种自底向上的方式求解动态规划问题，先求解较小的子问题，然后是较大的子问题。在贪心算法中，我们总是做出当时看起来最佳的选择，然后求解剩下的的唯一的子问题。贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或是子问题的解。因此，与动态规划先求解子问题，才能进行第一次选择不同，贪心算法在进行第一次选择之前不求解任何子问题。**一个动态规划算法是自底向上进行的，而一个贪心算法通常是自顶向下的，进行一次又一次选择，将给定问题实例变得更小。**

注：如果进行贪心选择时我们不得不考虑众多选择，通常意味着可以改进贪心选择，使其更为高效。例如，活动选择问题中，将活动按结束时间单调递增排序。通过对输入进行预处理或者使用更合适的数据结构（**通常是优先队列**），可以使贪心选择更快速，从而得到更高效的方法。

- 最优子结构

如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构。此性质是能否应用动态规划和贪心算法的关键因素。

## 活动选择问题


